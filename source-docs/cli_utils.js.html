<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: cli/utils.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: cli/utils.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module cli/utilities */

const cwd = process.cwd(); // Current working directory
const path = require('path');
const fs = require('fs-extra');
const chalk = require('chalk'); // Colorize terminal output

// Exports
/* eslint-disable */
export const utils = {
/* eslint-enable */

  /**
   * Ensure predictable data structure for KSS section data
   *
   * @function normalizeSectionData
   * @param {object} section - section data
   */
  normalizeSectionData(section) {
    const data = section.data || section;

    if (! data.referenceURI || '' === data.referenceURI) {
      data.referenceURI = section.referenceURI();
    }

    return data;
  },

  /**
   * Ensure predictable data structure for KSS section data
   *
   * @function writeSectionData
   * @param {object} store - data store
   * @param {object} section - section data
   * @param {string} sectionPath - output destination for section data file
   */
  writeSectionData(store, section, sectionPath = false) {
    let outputPath = sectionPath;
    let sectionFileInfo;

    if (! outputPath &amp;&amp; {}.hasOwnProperty.call(section, 'kssPath')) {
      sectionFileInfo = path.parse(section.kssPath);
      outputPath = path.join(
        sectionFileInfo.dir,
        `${sectionFileInfo.name}.json`
      );
    }

    // Output section data
    if (outputPath) {
      return utils.writeFile(
        section.referenceURI,
        'section',
        outputPath,
        JSON.stringify(section),
        store
      );
    }

    console.warn( // eslint-disable-line no-console
      chalk.red(`Failed to write section data for ${section.referenceURI}`)
    );
    return false;
  },

  /**
   * Find .json from a template file or vice versa
   *
   * @function getTemplateDataPair
   * @param {object} file - file object from path.parse()
   * @param {object} section - KSS section data
   */
  getTemplateDataPair(file, section, store) {
    const huron = store.get('config');
    const componentPath = path.relative(
      path.resolve(cwd, huron.get('kss')),
      file.dir
    );
    const partnerType = '.json' === file.ext ? 'template' : 'data';
    const partnerExt = '.json' === file.ext ?
      huron.get('templates').extension :
      '.json';

    const pairPath = path.join(
      componentPath,
      utils.generateFilename(
        section.referenceURI,
        partnerType,
        partnerExt,
        store
      )
    );

    return `./${pairPath}`;
  },

  /**
   * Normalize a section title for use as a filename
   *
   * @function normalizeHeader
   * @param {string} header - section header extracted from KSS documentation
   */
  normalizeHeader(header) {
    return header
      .toLowerCase()
      .replace(/\s?\W\s?/g, '-');
  },

  /**
   * Wrap html in required template tags
   *
   * @function wrapMarkup
   * @param {string} content - html or template markup
   * @param {string} templateId - id of template (should be section reference)
   */
  wrapMarkup(content, templateId) {
    return `&lt;dom-module>
&lt;template id="${templateId}">
${content}
&lt;/template>
&lt;/dom-module>\n`;
  },

  /**
   * Generate a filename based on referenceURI, type and file object
   *
   * @function generateFilename
   * @param  {string} id - The name of the file (with extension).
   * @param  {string} type - the type of file output
   * @param  {object} ext - file extension
   * @param  {store} store - data store
   * @return {string} Path to output file, relative to ouput dir (can be use in require statements)
   */
  generateFilename(id, type, ext, store) {
    // Type of file and its corresponding extension(s)
    const types = store.get('types');
    const outputExt = '.scss' !== ext ? ext : '.html';

    /* eslint-disable */
    if (-1 === types.indexOf(type)) {
      console.log(`Huron data ${type} does not exist`);
      return false;
    }
    /* eslint-enable */

    return `${id}-${type}${outputExt}`;
  },

  /**
   * Copy an HTML file into the huron output directory.
   *
   * @function writeFile
   * @param  {string} id - The name of the file (with extension).
   * @param  {string} content - The content of the file to write.
   * @param  {string} type - the type of file output
   * @param  {object} store - The data store
   * @return {string} Path to output file, relative to ouput dir (can be use in require statements)
   */
  writeFile(id, type, filepath, content, store) {
    const huron = store.get('config');
    const file = path.parse(filepath);
    const filename = utils.generateFilename(id, type, file.ext, store);
    const componentPath = path.relative(
      path.resolve(cwd, huron.get('kss')),
      file.dir
    );
    const outputRelative = path.join(
      huron.get('output'),
      componentPath,
      `${filename}`
    );
    const outputPath = path.resolve(cwd, huron.get('root'), outputRelative);
    let newContent = content;

    if ('data' !== type &amp;&amp; 'section' !== type) {
      newContent = utils.wrapMarkup(content, id);
    }

    try {
      fs.outputFileSync(outputPath, newContent);
      console.log(chalk.green(`Writing ${outputRelative}`)); // eslint-disable-line no-console
    } catch (e) {
      console.log(chalk.red(`Failed to write ${outputRelative}`)); // eslint-disable-line no-console
    }

    return `./${outputRelative.replace(`${huron.get('output')}/`, '')}`;
  },

  /**
   * Delete a file in the huron output directory
   *
   * @function removeFile
   * @param  {string} filename - The name of the file (with extension).
   * @param  {object} store - The data store
   * @return {string} Path to output file, relative to ouput dir (can be use in require statements)
   */
  removeFile(id, type, filepath, store) {
    const huron = store.get('config');
    const file = path.parse(filepath);
    const filename = utils.generateFilename(id, type, file.ext, store);
    const componentPath = path.relative(
      path.resolve(cwd, huron.get('kss')),
      file.dir
    );
    const outputRelative = path.join(
      huron.get('output'),
      componentPath,
      `${filename}`
    );
    const outputPath = path.resolve(cwd, huron.get('root'), outputRelative);

    try {
      fs.removeSync(outputPath);
      console.log(chalk.green(`Removing ${outputRelative}`)); // eslint-disable-line no-console
    } catch (e) {
      console.log( // eslint-disable-line no-console
        chalk.red(`${outputRelative} does not exist or cannot be deleted`)
      );
    }

    return `./${outputRelative.replace(`${huron.get('output')}/`, '')}`;
  },

  /**
   * Write a template for sections
   *
   * @function writeSectionTemplate
   * @param  {string} filepath - the original template file
   * @param  {object} store - data store
   * @return {object} updated store
   */
  writeSectionTemplate(filepath, store) {
    const huron = store.get('config');
    const sectionTemplate = utils.wrapMarkup(fs.readFileSync(filepath, 'utf8'));
    const componentPath = './huron-sections/sections.hbs';
    const output = path.join(
      cwd,
      huron.get('root'),
      huron.get('output'),
      componentPath
    );

    // Move huron script and section template into huron root
    fs.outputFileSync(output, sectionTemplate);
    console.log(chalk.green(`writing section template to ${output}`)); // eslint-disable-line no-console

    return store.set('sectionTemplatePath', componentPath);
  },

  /**
   * Request for section data based on section reference
   *
   * @function writeSectionTemplate
   * @param {string} search - key on which to match section
   * @param {field} string - field in which to look to determine section
   * @param {obj} sections - sections memory store
   */
  getSection(search, field, store) {
    const sectionValues = store
      .getIn(['sections', 'sectionsByPath'])
      .valueSeq();
    let selectedSection = false;

    if (field) {
      selectedSection = sectionValues
        .filter((value) => value[field] === search)
        .get(0);
    } else {
      selectedSection = store.getIn(['sections', 'sectionsByPath', search]);
    }

    return selectedSection;
  },
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-cli_actions.html">cli/actions</a></li><li><a href="module-cli_gaze.html">cli/gaze</a></li><li><a href="module-cli_generate-config.html">cli/generate-config</a></li><li><a href="module-cli_html-handler.html">cli/html-handler</a></li><li><a href="module-cli_kss-handler.html">cli/kss-handler</a></li><li><a href="module-cli_parse-arguments.html">cli/parse-arguments</a></li><li><a href="module-cli_require-templates.html">cli/require-templates</a></li><li><a href="module-cli_template-handler.html">cli/template-handler</a></li><li><a href="module-cli_utilities.html">cli/utilities</a></li><li><a href="module-cli_webpack-server.html">cli/webpack-server</a></li></ul><h3>Classes</h3><ul><li><a href="InsertNodes.html">InsertNodes</a></li></ul><h3>Global</h3><ul><li><a href="global.html#dataStructure">dataStructure</a></li><li><a href="global.html#extenstions">extenstions</a></li><li><a href="global.html#gaze">gaze</a></li><li><a href="global.html#huron">huron</a></li><li><a href="global.html#program">program</a></li><li><a href="global.html#store">store</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Dec 07 2016 11:56:01 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
