<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: cli/handle-kss.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: cli/handle-kss.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module cli/kss-handler */

import { utils } from './utils';
import { templateHandler } from './handle-templates';
import { writeStore } from './require-templates';

const path = require('path');
const fs = require('fs-extra');
const parse = require('kss').parse;
const chalk = require('chalk'); // Colorize terminal output

/* eslint-disable */
export const kssHandler = {
/* eslint-enable */

  /**
   * Handle update of a KSS section
   *
   * @function updateKSS
   * @param {string} filepath - filepath of changed file (comes from gaze)
   * @param {object} store - memory store
   */
  updateKSS(filepath, store) {
    const kssSource = fs.readFileSync(filepath, 'utf8');
    const huron = store.get('config');
    const oldSection = utils.getSection(filepath, false, store) || {};
    const file = path.parse(filepath);
    let newStore = store;

    if (kssSource) {
      const styleguide = parse(kssSource, huron.get('kssOptions'));

      if (styleguide.data.sections.length) {
        const section = utils.normalizeSectionData(
          styleguide.data.sections[0]
        );

        // Update or add section data
        newStore = kssHandler.updateSectionData(
          filepath,
          section,
          oldSection,
          newStore
        );

        // Remove old section data if reference URI has changed
        if (oldSection &amp;&amp;
          oldSection.referenceURI &amp;&amp;
          oldSection.referenceURI !== section.referenceURI
        ) {
          newStore = this.unsetSection(oldSection, file, newStore, false);
        }

        writeStore(newStore);
        console.log(
          chalk.green(
            `KSS source in ${filepath} changed or added`
          )
        );
        return newStore;
      }

      console.log(chalk.magenta(`No KSS found in ${filepath}`));
      return newStore;
    }

    if (oldSection) {
      newStore = kssHandler.deleteKSS(filepath, oldSection, newStore);
    }

    console.log(chalk.red(`${filepath} not found or empty`)); // eslint-disable-line no-console
    return newStore;
  },

  /**
   * Handle removal of a KSS section
   *
   * @function deleteKSS
   * @param {string} filepath - filepath of changed file (comes from gaze)
   * @param {object} section - KSS section data
   * @param {object} store - memory store
   */
  deleteKSS(filepath, section, store) {
    const file = path.parse(filepath);

    // Remove section data from memory store
    return kssHandler.unsetSection(section, file, store, true);
  },

  /**
   * Update the sections store with new data for a specific section
   *
   * @function updateSectionData
   * @param {object} section - contains updated section data
   * @param {string} kssPath - path to KSS section
   * @param {object} store - memory store
   */
  updateSectionData(kssPath, section, oldSection, store) {
    const sectionFileInfo = path.parse(kssPath);
    const dataFilepath = path.join(
      sectionFileInfo.dir,
      `${sectionFileInfo.name}.json`
    );
    const isInline = null !== section.markup.match(/&lt;\/[^>]*>/);
    const newSort = kssHandler.sortSection(
      store.getIn(['sections', 'sorted']),
      section.reference,
      store.get('referenceDelimiter')
    );
    const newSection = Object.assign({}, oldSection, section);
    let newStore = store;

    // Required for reference from templates and data
    newSection.kssPath = kssPath;

    if (isInline) {
      // Set section value if inlineTempalte() returned a path
      newStore = kssHandler.updateInlineTemplate(
        kssPath,
        oldSection,
        newSection,
        newStore
      );
    } else {
      // Remove inline template, if it exists
      utils.removeFile(
        newSection.referenceURI,
        'template',
        kssPath,
        store
      );
      // Update markup and data fields
      newStore = kssHandler.updateTemplateFields(
        sectionFileInfo,
        oldSection,
        newSection,
        newStore
      );
    }

    // Output section description
    newStore = kssHandler.updateDescription(
      kssPath,
      oldSection,
      newSection,
      newStore
    );

    // Output section data to a JSON file
    newSection.sectionPath = utils.writeSectionData(
      newStore,
      newSection,
      dataFilepath
    );

    // Update section sorting
    return newStore
      .setIn(
        ['sections', 'sorted'],
        newSort
      )
      .setIn(
        ['sections', 'sectionsByPath', kssPath],
        newSection
      )
      .setIn(
        ['sections', 'sectionsByURI', section.referenceURI],
        newSection
      );
  },

  /**
   * Handle detection and output of inline templates, which is markup written
   * in the KSS documentation itself as opposed to an external file
   *
   * @function updateInlineTemplate
   * @param {string} oldSection - previous iteration of KSS data, if updated
   * @param {object} section - KSS section data
   * @return {object} updated memory store with new template path info
   */
  updateInlineTemplate(filepath, oldSection, section, store) {
    const newSection = section;
    const newStore = store;

    // If we have inline markup
    if (this.fieldShouldOutput(oldSection, section, 'markup')) {
      newSection.templatePath = utils.writeFile(
        section.referenceURI,
        'template',
        filepath,
        section.markup,
        store
      );
      newSection.templateContent = section.markup;

      return newStore
        .setIn(
          ['sections', 'sectionsByPath', filepath],
          newSection
        )
        .setIn(
          ['sections', 'sectionsByURI', section.referenceURI],
          newSection
        );
    }

    return newStore;
  },

  /**
   * Handle output of section description
   *
   * @function updateDescription
   * @param {string} oldSection - previous iteration of KSS data, if updated
   * @param {object} section - KSS section data
   * @return {object} updated memory store with new descripton path info
   */
  updateDescription(filepath, oldSection, section, store) {
    const newSection = section;
    const newStore = store;

    // If we don't have previous KSS or the KSS has been updated
    if (this.fieldShouldOutput(oldSection, section, 'description')) {
      // Write new description
      newSection.descriptionPath = utils.writeFile(
        section.referenceURI,
        'description',
        filepath,
        section.description,
        store
      );

      return newStore
        .setIn(
          ['sections', 'sectionsByPath', filepath],
          newSection
        )
        .setIn(
          ['sections', 'sectionsByURI', section.referenceURI],
          newSection
        );
    }

    return newStore;
  },

  /**
   * Handle Data and Markup fields
   *
   * @function updateTemplateFields
   * @param {string} file - File data for KSS file from path.parse()
   * @param {object} oldSection - outdated KSS data
   * @param {object} section - KSS section data
   * @param {object} store - memory store
   * @return {object} KSS section data with updated asset paths
   */
  updateTemplateFields(file, oldSection, section, store) {
    const kssPath = path.format(file);
    const newSection = section;
    let filepath = '';
    let oldFilepath = '';
    let newStore = store;

    ['data', 'markup'].forEach((field) => {
      if (newSection[field]) {
        if (oldSection[field]) {
          oldFilepath = path.join(file.dir, oldSection[field]);
          newStore = templateHandler.deleteTemplate(
            oldFilepath,
            oldSection,
            newStore
          );
        }

        filepath = path.join(file.dir, newSection[field]);
        newStore = templateHandler.updateTemplate(
          filepath,
          newSection,
          newStore
        );
      } else {
        delete newSection[field];
        newStore = newStore
          .setIn(
            ['sections', 'sectionsByPath', kssPath],
            newSection
          )
          .setIn(
            ['sections', 'sectionsByURI', newSection.referenceURI],
            newSection
          );
      }
    });

    return newStore;
  },

  /**
   * Remove a section from the memory store
   *
   * @function unsetSection
   * @param {object} section - contains updated section data
   * @param {string} file - file object from path.parse()
   * @param {object} store - memory store
   * @param {bool} removed - has the file been removed or just the section information changed?
   */
  unsetSection(section, file, store, removed) {
    const sorted = store.getIn(['sections', 'sorted']);
    const kssPath = path.format(file);
    const dataFilepath = path.join(file.dir, `${file.name}.json`);
    const isInline = null !== section.markup.match(/&lt;\/[^>]*>/);
    const newSort = kssHandler.unsortSection(
      sorted,
      section.reference,
      store.get('referenceDelimiter')
    );
    let newStore = store;

    // Remove old section data
    utils.removeFile(
      section.referenceURI,
      'section',
      dataFilepath,
      newStore
    );

     // Remove associated inline template
    if (isInline) {
      utils.removeFile(section.referenceURI, 'template', kssPath, newStore);
    }

    // Remove description template
    utils.removeFile(section.referenceURI, 'description', kssPath, newStore);

    // Remove data from sectionsByPath if file has been removed
    if (removed) {
      newStore = newStore.deleteIn(['sections', 'sectionsByPath', kssPath]);
    }

    return newStore
      .deleteIn(['sections', 'sectionsByURI', section.referenceURI])
      .setIn(['sections', 'sorted'], newSort);
  },

  /**
   * Sort sections and subsections
   *
   * @function sortSection
   * @param {object} sorted - currently sorted sections
   * @param {string} reference - reference URI of section to sort
   */
  sortSection(sorted, reference, delimiter) {
    const parts = reference.split(delimiter);
    const newSort = sorted[parts[0]] || {};
    const newSorted = sorted;

    if (1 &lt; parts.length) {
      const newParts = parts.filter((part, idx) => 0 !== idx);
      newSorted[parts[0]] = kssHandler.sortSection(
        newSort,
        newParts.join(delimiter),
        delimiter
      );
    } else {
      newSorted[parts[0]] = newSort;
    }

    return newSorted;
  },

  /**
   * Remove a section from the sorted sections
   *
   * @function unsortSection
   * @param {object} sorted - currently sorted sections
   * @param {string} reference - reference URI of section to sort
   */
  unsortSection(sorted, reference, delimiter) {
    const parts = reference.split(delimiter);
    const subsections = Object.keys(sorted[parts[0]]);
    const newSorted = sorted;

    if (subsections.length) {
      if (1 &lt; parts.length) {
        const newParts = parts.filter((part, idx) => 0 !== idx);
        newSorted[parts[0]] = kssHandler.unsortSection(
          newSorted[parts[0]],
          newParts.join(delimiter),
          delimiter
        );
      }
    } else {
      delete newSorted[parts[0]];
    }

    return newSorted;
  },

  /**
   * Compare a KSS field between old and new KSS data to see if we need to output
   * a new module for that field
   *
   * @function fieldShouldOutput
   * @param {object} oldSection - currently sorted sections
   * @param {object} newSection - reference URI of section to sort
   * @param {string} field - KSS field to check
   */
  fieldShouldOutput(oldSection, newSection, field) {
    return (oldSection &amp;&amp;
        (oldSection[field] !== newSection[field] ||
        oldSection.referenceURI !== newSection.referenceURI)
      ) ||
      ! oldSection;
  },
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-cli_actions.html">cli/actions</a></li><li><a href="module-cli_gaze.html">cli/gaze</a></li><li><a href="module-cli_generate-config.html">cli/generate-config</a></li><li><a href="module-cli_html-handler.html">cli/html-handler</a></li><li><a href="module-cli_kss-handler.html">cli/kss-handler</a></li><li><a href="module-cli_parse-arguments.html">cli/parse-arguments</a></li><li><a href="module-cli_require-templates.html">cli/require-templates</a></li><li><a href="module-cli_template-handler.html">cli/template-handler</a></li><li><a href="module-cli_utilities.html">cli/utilities</a></li><li><a href="module-cli_webpack-server.html">cli/webpack-server</a></li></ul><h3>Classes</h3><ul><li><a href="InsertNodes.html">InsertNodes</a></li></ul><h3>Global</h3><ul><li><a href="global.html#dataStructure">dataStructure</a></li><li><a href="global.html#extenstions">extenstions</a></li><li><a href="global.html#gaze">gaze</a></li><li><a href="global.html#huron">huron</a></li><li><a href="global.html#program">program</a></li><li><a href="global.html#store">store</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Dec 07 2016 11:56:01 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
